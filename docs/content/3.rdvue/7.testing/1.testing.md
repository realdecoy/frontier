# Testing

## Cypress

Cypress is a JavaScript end-to-end testing framework that makes it easy to get started with structuring your tests for web applications. At its core, Cypress is not based on [Selenium](https://www.selenium.dev/projects/), instead, it is based on a architecture that runs in the same run-loop as your web application. Cypress offers a [API](https://docs.cypress.io/api/api/table-of-contents.html) that allows developers and QA Engineers a lot of flexibility to make tests. Examples would be offering the ability to do mocking of network requests, taking screenshots or recording your network activity.

End-to-End (e2e) tests are usually tests that are focused on simulating user interactions. Cypress provides all the necessary dependencies to create these e2e tests and also to debug them if necessary.

### Technical

Within a project generated by the CLI tool, the following folder structure will be created:

<img src="https://github.com/realdecoy/rdvue/blob/main/docs/images/cypress.png?raw=true">

All the e2e tests created by Cypress will live in the **cypress/integration/specs** directory. All these test files will have a .ts extension as they are written in TypeScript.

An example of a test file written in Cypress can be seen below:

```
// Example spec file to see the different methods that can be used in Cypress to set the current viewport
/// <reference types="Cypress" />

context('Viewport Examples', () => {
    beforeEach(() => {
      cy.visit('https://example.cypress.io/commands/viewport');
    });

    it('cy.viewport() - set the viewport size and dimension', () => {
      // https://on.cypress.io/viewport

      cy.get('#navbar').should('be.visible');
      cy.viewport(320, 480);

      // the navbar should have collapse since our screen is smaller
      cy.get('#navbar').should('not.be.visible');
      cy.get('.navbar-toggle').should('be.visible').click();
      cy.get('.nav').find('a').should('be.visible');

      // lets see what our app looks like on a super large screen
      cy.viewport(2999, 2999);

      // cy.viewport() accepts a set of preset sizes
      // to easily set the screen to a device's width and height

      // We added a cy.wait() between each viewport change so you can see
      // the change otherwise it is a little too fast to see :)

      cy.viewport('macbook-15');
      cy.wait(200);
      cy.viewport('macbook-13');
      cy.wait(200);
      cy.viewport('macbook-11');
      cy.wait(200);
      cy.viewport('ipad-2');
      cy.wait(200);
      cy.viewport('ipad-mini');
      cy.wait(200);
      cy.viewport('iphone-6+');
      cy.wait(200);
      cy.viewport('iphone-6');
      cy.wait(200);
      cy.viewport('iphone-5');
      cy.wait(200);
      cy.viewport('iphone-4');
      cy.wait(200);
      cy.viewport('iphone-3');
      cy.wait(200);

      // cy.viewport() accepts an orientation for all presets
      // the default orientation is 'portrait'
      cy.viewport('ipad-2', 'portrait');
      cy.wait(200);
      cy.viewport('iphone-4', 'landscape');
      cy.wait(200);

      // The viewport will be reset back to the default dimensions
      // in between tests (the  default can be set in cypress.json)
    });
  });
```

By default, all projects get sample tests generated for them which contain several examples for selecting elements, automating navigation and changing view ports for more responsive UI tests.

?>When you are testing the connection between pages and user flows, a Cypress test should be created.

### Running tests

In order to run your Cypress tests, execute **npm run test:e2e** and the following dialog will open

<image src="https://github.com/realdecoy/rdvue/blob/main/docs/images/inspection.png?raw=true"> 

From here, you can click on the **Run all specs** option and see all the tests execute or you can click on a specific test file and see that test execute.

?>Your application should be running on localhost or hosted at a url before trying to setup e2e tests.

## Unit Tests with Jest

Unit tests are focused on validating small bits of functionality in a software product. Unit tests can be done manually or they can be automated. If you wish to learn more about unit testing and approaches that can be taken.

If you wish to automate your unit tests, [Jest](https://jestjs.io/) can be used. Jest is a JavaScript testing framework that can be integrated into several different JavaScript frameworks and it is very useful for certain use cases.

### Technical

Each component generated by the RDVue CLI comes with a <component-name>.spec.js file and the folder structure will look like the following:

<image src="https://github.com/realdecoy/rdvue/blob/main/docs/images/unitTest1.png?raw=true">

The spec file generated will contain the following basic test by default:

<image src="https://github.com/realdecoy/rdvue/blob/main/docs/images/unitTest2.png?raw=true">)

This file is using the expect assertion library that comes with Jest and also the shallowMount method that is available to us through the ‘@vue/test-utils' library. Jest comes pre-packaged with Mocha which is enables us to use the 'describe/it’ setup to describe our test suite and our specific test case respectively.

shallowMount is used to mock or simulate what would happen to the component if it was actually mounted to the DOM. The .exists() method is used with shallowMount in order to check that the component was actually mounted and it does exist in the DOM.