# Native Mobile Features

The Native Mobile extension modifies some of [RDVue's features](./Features.md) to behave within
a native mobile environment. The following sections explain what has changed
and what is new.

## Services

Services are focused classed designed to interact with web API endpoints. As a good design pattern a service should:

*   only interact with a single domain
    
*   only provide features from the domain which are relevant to the theme of the service. Eg. A user service should be focused on methods support such; adding order related data would make for poor encapsulation.
    

### Technical

*   Each service is able to specify a unique web API endpoint with which to interact - or none at all for services providing local functionality (Eg. wrapper storage mechanism over LocalStorage).
*   Please refer to [NativeScript's Request Method Documentation](https://docs.nativescript.org/http.html#request)

## Pages

A Page is a conceptual grouping for Vue Components used in routing. Pages are **not** to be imported by other Pages, Components or Layouts.

?> A route is automatically added to `config/route.ts`.

### Technical

Each generated Page is contained within it’s own sub-folder within the **src/pages** directory. The directory contains the following files which each carry out a specific role in developing a Page:

*   \[page\].**vue**: This contains the Vue template markup used to implement the structure and layout of a Page. It is a mix of HTML and special Vue syntaxes which allow declarative databinding and structural manipulation.
    
*   \[page\].**ts**: This contains the TypeScript controller which provides the procedural code-behind logical needed to add integrations to a page. Through this file you may expose data and handle events generated by Page elements.
    
*   \[page\].**scss**: This contains the SASS stylesheet to be applied to the page - and that page only. The styles within this file are scoped, meaning they cannot be used to target any elements except those defined directly within the \[page\].vue template file.
    

?> Scoped CSS may seem weird at first because regular CSS operates with global impunity, however it is a great approach for compartmentalizing styles so they do not jump their intended scope and affect other elements. Global level styles can be added in the Theme directory.


## Routing

In order to determine the pages that get loaded for a particular path within the emulator or device, routes are setup to create the respective mappings.

Below is an example of a route definition for a sample login page:

```
export const routes: Array<Route> = [
    {
        path: '/login',
        name: 'Login',
        options: {
            props: {
                value: 'im a value'
            }
        }
    },
];
```

The **path** property specifies where the page will be accessible under the domain.

The **name** field provides an alternative means of identifying and navigation to defined pages programatically. This approach is preferable because the route names can be externalized into global constants and shared throughout your code for navigational consistency.

The **options** property allows specifying arbitrary data that will get passed along to the loaded Page. For additional information on the options that can be passed to a page, please refer to [NativeScript's documentation](https://nativescript-vue.org/en/docs/routing/manual-routing/#passing-props-to-the-target-component).

## Components

Each generated component is contained within it’s own sub-folder within the **src/components** directory. The directory contains the following files which each carry out a specific role in developing a component:

*   \[component\].**vue**: This contains the Vue template markup used to implement the structure and layout of a component. It is a mix of HTML and special Vue syntaxes which allow declarative databinding and structural manipulation.
    
*   \[component\].**ts**: This contains the TypeScript controller which provides the procedural code-behind logical needed to add integrations to a component. Through this file you may expose data and handle events generated by component elements.
    
*   \[component\].**scss**: This contains the SASS stylesheet to be applied to the component - and that component only. The styles within this file are scoped, meaning they cannot be used to target any elements except those defined directly within the \[component\].vue template file.
    

?> Scoped CSS may seem weird at first because regular CSS operates with global impunity, however it is a great approach for compartmentalizing styles so they do not jump their intended scope and affect other elements. Global level styles can be added in the Theme directory.

## Stores

A Store is a mechanism for maintain application state in a way which is globally accessible to all components. We use them as intermediary layers to issue API calls to relevant services, and cache the results for \[re\]use. Though the thought may occur to use a plain JavaScript object to achieve state management, a Vue Store differs in two distinct ways:

*   Properties are reactive. Changing Store values will automatically propagate to the component-level bindings which use them.
    
*   Stores enforce a strong process-control for mutating values. Every change within a store **must** go through a specially designed method, called a **Mutation**, in order to update an internal value.
    

An application can have as many Stores as needed to logically group state concerns. The RDVue CLI creates strongly typed Stores, enabling full Intellisense and compiler support when writing code against them.

Data within a Store can be managed using 3 intrinsic functionalities of every Store:

*   Getters: Retrieve a value within the store.
    
*   Actions - Arbitrary, asynchronous, functions which can perform business logic and invoke mutations.
    
*   Mutations - Special, synchronous, functions which only update the values in Store. The operate atomically, meaning their changes are indivisible.

### Technical

A Store consists of a standard Class, with **Decorators** providing the special functionality:

*   The **@Module** Decorator is added to the class itself and will be preconfigured with the necessary options whenever you use the CLI to create a new Store.
    
*   The **@Action** Decorator is added to the class’ methods that want to carry-out business logic and be able to persist the result of that into state. @MultiParamAction is preferred over this Decorator due to Vuex quirks in how multiple parameters are handled.
    

?>If multiple parameters are used in a base @Action, the real value of the first parameter will be an array with a payload object, and the second parameter will be an options object. This will likely be entirely misaligned from the type information you specified in TypeScript.

*   The **@MultiParamAction** Decorator is the preferred alternative to @Action because it allows methods to receive multiple parameters.
    
*   The **@Mutation** Decorator flags a method as being able to update the Store’s state. That means any fields which belong to the class may be set within the execution context of these methods.
    

!>Attempting to modify a field outside of a method marked with @Mutation will result in a runtime error with the Vuex framework.



## Unavailable Features
RDVue Mobile currently does not support Layouts, Localization, and Bundle Analysis
